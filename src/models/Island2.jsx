/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useEffect } from "react";
import { useGLTF } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import Island2Scene from "../assets/3d/island2.glb"


const Island2 = ({isRotating,rotatingFunction, currentStage,setCurrentStage,  ...props})  =>{
  // une des modifications que j'ai apportÃ©  
  const { nodes, materials } = useGLTF(Island2Scene);
  // Island2ref est la reference de l'ile
  const Island2ref = useRef()
  // gl est le contexte webgl. necessaire pour ajouter des evenements sur le canvas
  // viewport est la taille de l'ecran
  const {gl, viewport} = useThree()
  // PositionCurseur est la derniere position du pointeur de la souris
  //rotation_speed est la derniere rotation de l'ile
  // rotation_coef est le coefficient de vitesse de rotation
  const PositionCurseur = useRef(0)
  const rotation_speed = useRef(0)
  const rotation_coef = 0.95;


  const mouseClicked = ( event ) =>{
    // c'est pour limiter l'evenement au canvas
    event.stopPropagation();
    // c'est pour empecher le navigateur d'effectuer des actions par defaut comme reload la page quand un evenement se realise
    event.preventDefault();
    rotatingFunction(true);
    //
    const clientX = event.clientX || event.touches[0].clientX;
    PositionCurseur.current = clientX;
  }

  const mouseRelease = ( event ) =>{
    event.stopPropagation();
    event.preventDefault();
    rotatingFunction(false);

  }

  const mouseMove = ( event ) =>{
    event.stopPropagation();
    event.preventDefault();
    if(isRotating){
      // on recupere la valeur actuer du pointeur de la souris
    const clientX = event.clientX || event.changedTouches[0].clientX;

    // on calcule la difference entre la derniere valeur et la valeur actuel
    // on divise par la largeur de l'ecran pour avoir un nombre entre 0 et 1 
    // on normalise par rapport au viewport car on veut la position par rapport au viewport et 
    // pas par rapport a l'ecran
    const delta = (clientX - PositionCurseur.current)/viewport.width;

    // on se deplace de facon horizontale
    // on fait un angle selon l'axe z
    Island2ref.current.rotation.z += delta * Math.PI * 0.01;
    PositionCurseur.current = clientX;
    // on multiplie par PI pour avoir un angle
    rotation_speed.current = delta * Math.PI * 0.01;
    }
  }
  useFrame(() => {
  if(!isRotating){
    rotation_speed.current *= rotation_coef;
    if(Math.abs(rotation_speed.current) < 0.0000001){
      rotation_speed.current = 0;
    }
    // on se deplace de facon horizontale
      Island2ref.current.rotation.z += rotation_speed.current;
  }
  else{
     // When rotating, determine the current stage based on island's orientation
      const rotation = Island2ref.current.rotation.z;
      const normalizedRotation =
        ((rotation % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);

      // Set the current stage based on the island's orientation
      switch (true) {
        case normalizedRotation >= 5.0 && normalizedRotation <= 5.40:
          setCurrentStage(4);
          break;
        case normalizedRotation >= 0.55 && normalizedRotation <= 1.05:
          setCurrentStage(3);
          break;
        case normalizedRotation >= 2.4 && normalizedRotation <= 2.6:
          setCurrentStage(2);
          break;
        case normalizedRotation >= 3.15 && normalizedRotation <= 3.65:
          setCurrentStage(1);
          break;
        default:
          setCurrentStage(null);
      }
    }
  });


  useEffect(() => {
    // afin de s'assurer que l'on travaille sur le canvas
    const canvas = gl.domElement;
    canvas.addEventListener('mousedown', mouseClicked);
    canvas.addEventListener('mouseup', mouseRelease);
    canvas.addEventListener('mousemove', mouseMove);
    return () => {
      canvas.removeEventListener('mousedown', mouseClicked);
      canvas.removeEventListener('mouseup', mouseRelease);
      canvas.removeEventListener('mousemove', mouseMove);
    }
  }, [gl,mouseClicked,mouseRelease,mouseMove]);

  return (
    <group ref ={Island2ref} {...props} >
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube_grass_0_1.geometry}
            material={materials["grass.250"]}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube_grass_0_2.geometry}
            material={materials["wood2.015"]}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube_grass_0_3.geometry}
            material={materials["stone.013"]}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube_grass_0_4.geometry}
            material={materials["roof.056"]}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube_grass_0_5.geometry}
            material={materials["wood1.002"]}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube_grass_0_6.geometry}
            material={materials["stone3.006"]}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube_grass_0_7.geometry}
            material={materials.material_0}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube_grass_0_8.geometry}
            material={materials["foliage1.041"]}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube_grass_0_9.geometry}
            material={materials["stone2.009"]}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube_grass_0_10.geometry}
            material={materials["wood1.007"]}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube_grass_0_11.geometry}
            material={materials.dirt}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube_grass_0_12.geometry}
            material={materials["foliage2.005"]}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube_grass_0_13.geometry}
            material={materials.material_1}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube_grass_0_14.geometry}
            material={materials.water}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube_grass_0_15.geometry}
            material={materials.darkness}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube_grass_0_16.geometry}
            material={materials.wood3}
          />
        </group>
  );
}

export default Island2
